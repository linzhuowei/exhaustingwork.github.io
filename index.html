<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ä¾¿åˆ©è´´</title>
		<style>
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
				background-image: linear-gradient(0deg, #eee 1px, transparent 0),
					linear-gradient(90deg, #eee 1px, transparent 0);
				background-size: 30px 30px;
				color: #333;
				min-height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile {
				overflow-y: auto;
			}

			#board {
				position: relative;
				width: 100vw;
				height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile #board {
				height: auto;
				min-height: 100dvh;
			}

			/* ä¾¿åˆ©è´´æ ·å¼ä¼˜åŒ– */
			.card {
				position: absolute;
				width: 220px;
				border-radius: 4px; /* ä¾¿åˆ©è´´æ›´æ‰å¹³çš„åœ†è§’ */
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12); /* æ›´è‡ªç„¶çš„é˜´å½± */
				background: #fff;
				border: none;
				overflow: hidden;
				opacity: 0;
				transform-origin: center;
				transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
					top 0.35s ease, width 0.35s ease, height 0.35s ease,
					border-radius 0.35s ease;
				/* ä¾¿åˆ©è´´è½»å¾®è¤¶çš±æ•ˆæœ */
				background-image: linear-gradient(135deg, rgba(0,0,0,0.02) 0%, rgba(0,0,0,0.05) 100%);
			}

			/* ä¾¿åˆ©è´´é¡¶éƒ¨é’‰å­”æ•ˆæœ */
			.card::before {
				content: '';
				position: absolute;
				top: 8px;
				left: 50%;
				transform: translateX(-50%);
				width: 12px;
				height: 12px;
				border-radius: 50%;
				background: rgba(150,150,150,0.3);
				box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
			}

			.card.dragging {
				transition: none;
				box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
				transform: scale(1.02);
			}

			.card.maximized {
				box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
				border-radius: 8px;
			}

			.card-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 20px 12px 10px; /* é¡¶éƒ¨ç•™å‡ºé’‰å­”ç©ºé—´ */
				background: transparent;
				cursor: grab;
				user-select: none;
				touch-action: pan-y;
			}

			.card-header.dragging {
				cursor: grabbing;
			}

			.window-controls {
				display: flex;
				align-items: center;
				gap: 6px;
			}

			.window-controls .control {
				position: relative;
				width: 10px;
				height: 10px;
				border-radius: 50%;
				border: 1px solid rgba(0, 0, 0, 0.08);
				background: #ccc;
				cursor: pointer;
				outline: none;
				padding: 0;
				display: inline-flex;
				align-items: center;
				justify-content: center;
			}

			.window-controls .control.close {
				background: #ff5f57;
				border-color: #e0443e;
			}

			.window-controls .control.minimize {
				background: #febb2e;
				border-color: #dea123;
			}

			.window-controls .control.maximize {
				background: #28c840;
				border-color: #1aab2c;
			}

			.window-controls .control::after {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				opacity: 0;
				transition: opacity 0.2s ease;
			}

			.card-header:hover .window-controls .control::after {
				opacity: 0.8;
			}

			.window-controls .control.close::after {
				content: 'Ã—';
				width: auto;
				height: auto;
				background: none;
				font-size: 8px;
				line-height: 1;
				font-weight: 700;
				color: rgba(0, 0, 0, 0.7);
			}

			.window-controls .control.minimize::after {
				width: 5px;
				height: 1px;
				background: rgba(0, 0, 0, 0.6);
			}

			.window-controls .control.maximize::after {
				width: 5px;
				height: 5px;
				background: linear-gradient(
					45deg,
					rgba(0, 0, 0, 0.6) 0%,
					rgba(0, 0, 0, 0.6) 45%,
					transparent 45%,
					transparent 55%,
					rgba(0, 0, 0, 0.6) 55%,
					rgba(0, 0, 0, 0.6) 100%
				);
			}

			.card-title {
				font-size: 11px;
				font-weight: 600;
				color: rgba(0, 0, 0, 0.4);
				padding-left: 10px;
				flex: 1;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			}

			.card-body {
				padding: 0 16px 16px;
				font-size: 15px;
				line-height: 1.5;
				font-weight: 500;
				color: rgba(0, 0, 0, 0.75);
				min-height: 80px;
				display: flex;
				align-items: center;
			}

			/* æœ€å¤§åŒ–çŠ¶æ€ä¸‹çš„å†…å®¹æ ·å¼ */
			.card.maximized .card-body {
				font-size: 24px;
				padding: 40px;
				min-height: calc(100vh - 80px);
				text-align: center;
			}

			.card.maximized::before {
				display: none; /* æœ€å¤§åŒ–æ—¶éšè—é’‰å­” */
			}

			.card.maximized .card-header {
				padding-top: 12px;
			}

			@media (max-width: 768px) {
				.card {
					width: 160px;
					border-radius: 3px;
				}

				.card-body {
					padding: 0 12px 12px;
					font-size: 13px;
				}

				.card-title {
					font-size: 10px;
				}

				.card.maximized .card-body {
					font-size: 18px;
					padding: 20px;
				}
			}
		</style>
	</head>
	<body>
		<div id="board"></div>

		<script>
			const board = document.getElementById('board')
			// ä¸Šç­åæ§½å†…å®¹åº“
			const messages = [
				'å‘¨ä¸€ä¸ºä»€ä¹ˆè¦ä¸Šç­å•ŠğŸ˜©',
				'å’–å•¡ç»­å‘½ï¼Œä¸€å¤©ä¸‰æ¯â˜•',
				'è¿™ä¸ªéœ€æ±‚åˆæ”¹äº†ï¼ŸğŸ¤¯',
				'ä»€ä¹ˆæ—¶å€™æ‰èƒ½ä¸‹ç­å•Š',
				'å¼€ä¼šä¸¤å°æ—¶ï¼Œå¹²æ´»äº”åˆ†é’Ÿ',
				'å¥½æƒ³æ‘¸é±¼ä½†ä¸æ•¢ğŸŸ',
				'å‘¨æœ«è¿‡å¾—ä¹Ÿå¤ªå¿«äº†',
				'ä»Šå¤©ä¹Ÿæ˜¯å›°åˆ°çä¸å¼€çœ¼ğŸ’¤',
				'å·¥èµ„æ²¡æ¶¨ï¼Œå·¥ä½œé‡ç¿»å€',
				'ä¸æƒ³ä¸Šç­ï¼Œæƒ³é€€ä¼‘',
				'è¿™ä¸ªbugåˆ°åº•åœ¨å“ªå•Š',
				'åˆè¦åŠ ç­ï¼Œæˆ‘çš„å¤©ğŸ˜­',
				'æ‘¸é±¼ä½¿æˆ‘å¿«ä¹ï¼Œå·¥ä½œä½¿æˆ‘ç–²æƒ«',
				'å®¢æˆ·çš„è¦æ±‚è¶Šæ¥è¶Šç¦»è°±',
				'æ¯å¤©éƒ½åœ¨ç›¼å‘¨äº”',
				'å†åšæŒä¸€ä¸‹ï¼Œå¿«ä¸‹ç­äº†',
				'ä¸ºä»€ä¹ˆè¦å¼€è¿™ä¹ˆå¤šæ— æ•ˆä¼šè®®',
				'æˆ‘çš„çµé­‚å·²ç»ä¸‹ç­äº†',
				'èµ·åºŠå›°éš¾æˆ·ï¼Œä¸Šç­ç‰¹å›°ç”Ÿ',
				'å’–å•¡å–å¤šäº†ï¼Œæ™šä¸Šç¡ä¸ç€',
				'ä¸Šç­å¦‚ä¸ŠåŸï¼Œå¿ƒæƒ…æ²‰é‡',
				'è¿™ä¸ªç­æ˜¯éä¸Šä¸å¯å—',
				'å¥½æƒ³è¯·å‡ä¼‘æ¯ä¸€å¤©',
				'ç”µè„‘å¡äº†ï¼Œäººä¹Ÿå¡äº†',
				'å·¥èµ„æ¡ä¸‹æ¥ï¼Œå¿ƒå‡‰äº†åŠæˆª',
				'åŒäº‹å·ä¸åŠ¨äº†ï¼Œæˆ‘ä¹Ÿå·ä¸åŠ¨äº†',
				'åˆä¼‘æ—¶é—´èƒ½ä¸èƒ½é•¿ä¸€ç‚¹',
				'ä¸Šç­çš„æ„ä¹‰æ˜¯ä»€ä¹ˆ',
				'æ‘¸é±¼æ—¶æ€»æ„Ÿè§‰è€æ¿åœ¨èº«å',
				'æ¯å¤©é‡å¤åŒæ ·çš„å·¥ä½œ',
				'çœ¼ç›ç›¯ç€å±å¹•ï¼Œè„‘å­ä¸€ç‰‡ç©ºç™½',
				'å†ç†¬å‡ å¤©å°±åˆ°å‘¨æœ«äº†',
				'ä¸ºä»€ä¹ˆé‚®ä»¶æ°¸è¿œå›å¤ä¸å®Œ',
				'æ‰“å°æœºåˆåäº†ï¼',
				'åˆé¥­å¥½éš¾åƒï¼Œè¿˜è´µ'
			]

			// ä¾¿åˆ©è´´é¢œè‰²åº“ï¼ˆæ›´è´´è¿‘çœŸå®ä¾¿åˆ©è´´ï¼‰
			const colors = [
				'#fff9c4', // æµ…é»„è‰²
				'#ffe0e3', // æµ…ç²‰è‰²
				'#c7f0ff', // æµ…è“è‰²
				'#d9f2d9', // æµ…ç»¿è‰²
				'#e5d7ff', // æµ…ç´«è‰²
				'#ffd8a8', // æµ…æ©™è‰²
				'#f9f7d9', // ç±³é»„è‰²
				'#d2f0f8', // æ·¡é’è‰²
				'#ffd4f5', // æ·¡ç²‰è‰²
				'#e8f5e9', // å«©ç»¿è‰²
				'#f0e6ff', // æ·¡ç´«è‰²
				'#fff0e0'  // æµ…æ©™è‰²
			]

			const cardStates = new WeakMap()
			const MAXIMIZED_LAYER = 1000000
			let activeMaximizedCard = null
			let isMobile =
				window.matchMedia('(pointer: coarse)').matches ||
				window.innerWidth <= 768
			const maxCards = isMobile ? 120 : 180
			const initialCardCount = isMobile ? 18 : 30
			const spawnInterval = isMobile ? 700 : 400
			let zIndexCursor = 200

			document.body.classList.toggle('is-mobile', isMobile)

			function randomFrom(array) {
				return array[Math.floor(Math.random() * array.length)]
			}

			function clamp(value, min, max) {
				return Math.min(Math.max(value, min), max)
			}

			function applyTransform(card, state) {
				const scale = state.scale ?? 1
				const translateX = state.translateX ?? 0
				const translateY = state.translateY ?? 0
				const angle = state.angle ?? 0
				card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`
			}

			function bringToFront(card) {
				if (card === activeMaximizedCard) {
					card.style.zIndex = MAXIMIZED_LAYER
					return
				}

				zIndexCursor += 1
				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
					zIndexCursor = MAXIMIZED_LAYER - 1
				}

				card.style.zIndex = zIndexCursor
			}

			function setupCardInteractions(card) {
				const header = card.querySelector('.card-header')
				const closeBtn = card.querySelector('.control.close')
				const minimizeBtn = card.querySelector('.control.minimize')
				const maximizeBtn = card.querySelector('.control.maximize')

				closeBtn.addEventListener('click', event => {
					event.stopPropagation()
					closeCard(card)
				})

				minimizeBtn.addEventListener('click', event => {
					event.stopPropagation()
					minimizeCard(card)
				})

				maximizeBtn.addEventListener('click', event => {
					event.stopPropagation()
					toggleMaximize(card)
				})

				header.addEventListener('pointerdown', event => {
					if (event.pointerType === 'touch') return
					startDrag(event, card)
				})

				card.addEventListener('pointerdown', () => {
					bringToFront(card)
				})

				header.addEventListener('dblclick', event => {
					if (!event.target.closest('.control')) {
						toggleMaximize(card)
					}
				})
			}

			function closeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return
				if (card === activeMaximizedCard) {
					activeMaximizedCard = null
				}
				state.closing = true
				state.scale = 0.1
				card.style.opacity = '0'
				applyTransform(card, state)

				const handleTransitionEnd = event => {
					if (event.propertyName === 'opacity') {
						card.removeEventListener('transitionend', handleTransitionEnd)
						card.remove()
					}
				}

				card.addEventListener('transitionend', handleTransitionEnd)
			}

			function minimizeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				const runMinimize = () => {
					state.closing = true
					bringToFront(card)
					const bottom = Math.max(window.innerHeight - 24, 0)
					const targetLeft = clamp(
						state.left,
						16,
						Math.max(window.innerWidth - card.offsetWidth - 16, 16)
					)

					state.left = targetLeft
					state.top = bottom
					state.scale = 0.1
					state.angle = 0
					card.style.left = `${targetLeft}px`
					card.style.top = `${bottom}px`
					card.style.opacity = '0.35'
					applyTransform(card, state)

					const handleTransitionEnd = event => {
						if (event.propertyName === 'transform') {
							card.removeEventListener('transitionend', handleTransitionEnd)
							card.remove()
						}
					}

					card.addEventListener('transitionend', handleTransitionEnd)
				}

				if (state.maximized) {
					activeMaximizedCard = null
					state.maximized = false
					card.classList.remove('maximized')
					card.style.borderRadius = '4px'
					state.left = 0
					state.top = 0
					state.scale = 1
					state.angle = 0
					applyTransform(card, state)

					requestAnimationFrame(() => {
						requestAnimationFrame(runMinimize)
					})
					return
				}

				runMinimize()
			}

			function toggleMaximize(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				if (state.maximized) {
					restoreFromMaximize(card, state)
				} else {
					maximizeCard(card, state)
				}
			}

			function maximizeCard(card, state) {
				if (activeMaximizedCard) {
					restoreFromMaximize(activeMaximizedCard, cardStates.get(activeMaximizedCard))
				}

				state.beforeMaximize = {
					left: state.left,
					top: state.top,
					scale: state.scale ?? 1,
					width: card.offsetWidth,
					height: card.offsetHeight,
					angle: state.angle ?? 0
				}

				state.maximized = true
				activeMaximizedCard = card
				card.classList.add('maximized')
				card.style.width = '100vw'
				card.style.height = '100vh'
				card.style.left = '0'
				card.style.top = '0'
				card.style.zIndex = MAXIMIZED_LAYER
				
				state.angle = 0
				state.scale = 1
				state.translateX = 0
				state.translateY = 0
				
				applyTransform(card, state)
			}

			function restoreFromMaximize(card, state) {
				if (!state.beforeMaximize) return

				state.maximized = false
				activeMaximizedCard = null
				card.classList.remove('maximized')
				
				card.style.width = `${state.beforeMaximize.width}px`
				card.style.height = `${state.beforeMaximize.height}px`
				card.style.left = `${state.beforeMaximize.left}px`
				card.style.top = `${state.beforeMaximize.top}px`
				
				state.scale = state.beforeMaximize.scale
				state.angle = state.beforeMaximize.angle
				state.beforeMaximize = null
				
				applyTransform(card, state)
				bringToFront(card)
			}

			function startDrag(event, card) {
				const state = cardStates.get(card)
				if (!state || state.maximized || state.closing) return

				event.preventDefault()
				const header = card.querySelector('.card-header')
				header.classList.add('dragging')
				card.classList.add('dragging')
				
				const startX = event.clientX
				const startY = event.clientY
				const initialLeft = state.left
				const initialTop = state.top

				const handleMouseMove = (moveEvent) => {
					const dx = moveEvent.clientX - startX
					const dy = moveEvent.clientY - startY
					
					state.left = initialLeft + dx
					state.top = initialTop + dy
					
					card.style.left = `${state.left}px`
					card.style.top = `${state.top}px`
				}

				const handleMouseUp = () => {
					header.classList.remove('dragging')
					card.classList.remove('dragging')
					document.removeEventListener('mousemove', handleMouseMove)
					document.removeEventListener('mouseup', handleMouseUp)
				}

				document.addEventListener('mousemove', handleMouseMove)
				document.addEventListener('mouseup', handleMouseUp)
				bringToFront(card)
			}

			function createCard() {
				if (board.children.length >= maxCards) return

				const card = document.createElement('div')
				card.className = 'card'
				
				// è®¾ç½®éšæœºé¢œè‰²
				const color = randomFrom(colors)
				card.style.backgroundColor = color
				
				// éšæœºä½ç½®
				const left = Math.random() * (window.innerWidth - 240)
				const top = Math.random() * (window.innerHeight - 200)
				
				// éšæœºè§’åº¦
				const angle = (Math.random() - 0.5) * 8
				
				card.style.left = `${left}px`
				card.style.top = `${top}px`
				
				// éšæœºå†…å®¹
				const message = randomFrom(messages)
				
				card.innerHTML = `
					<div class="card-header">
						<div class="card-title">åæ§½ä¾¿åˆ©è´´</div>
						<div class="window-controls">
							<button class="control close" aria-label="å…³é—­"></button>
							<button class="control minimize" aria-label="æœ€å°åŒ–"></button>
							<button class="control maximize" aria-label="æœ€å¤§åŒ–"></button>
						</div>
					</div>
					<div class="card-body">${message}</div>
				`
				
				board.appendChild(card)
				
				// å­˜å‚¨å¡ç‰‡çŠ¶æ€
				cardStates.set(card, {
					left,
					top,
					angle,
					maximized: false,
					closing: false
				})
				
				// è®¾ç½®åˆå§‹åŠ¨ç”»
				applyTransform(card, {
					...cardStates.get(card),
					scale: 0.5
				})
				
				// è§¦å‘åŠ¨ç”»
				setTimeout(() => {
					card.style.opacity = '1'
					applyTransform(card, cardStates.get(card))
				}, 10)
				
				// è®¾ç½®äº¤äº’
				setupCardInteractions(card)
				
				// è®¾ç½®z-index
				bringToFront(card)
			}

			// åˆå§‹åŒ–åˆ›å»ºä¾¿åˆ©è´´
			function initCards() {
				for (let i = 0; i < initialCardCount; i++) {
					setTimeout(createCard, i * spawnInterval / 3)
				}

				// å®šæ—¶æ·»åŠ æ–°å¡ç‰‡
				setInterval(createCard, spawnInterval)
			}

			// å¯åŠ¨åº”ç”¨
			initCards()
		</script>
	</body>
</html>